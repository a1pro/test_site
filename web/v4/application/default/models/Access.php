<?php
/**
 * Class represents records from table access
 * {autogenerated}
 * @property int $access_id 
 * @property int $invoice_id 
 * @property int $invoice_payment_id 
 * @property int $user_id 
 * @property int $product_id 
 * @property string $transaction_id 
 * @property date $begin_date 
 * @property date $expire_date 
 * @see Am_Table
 */
class Access extends Am_Record {
    protected $_disableHooks = false;
    
    const EXPIRED = 0;
    const ACTIVE = 1;
    const FUTURE = 2;
    
    function isLifetime(){
        return $this->expire_date >= Am_Period::RECURRING_SQL_DATE ||
               $this->expire_date >= Am_Period::MAX_SQL_DATE;
    }
    
    /**
     * @return int status constant
     */
    function getStatus()
    {
        $now = sqlDate('now');
        if ($this->expire_date < $now) return self::EXPIRED;
        if ($this->begin_date > $now) return self::FUTURE;
        return self::ACTIVE;
    }

    /**
     * Disable any external hooks calling during this record add/delete/update
     * Do just SQL staff if true
     */
    function setDisableHooks($flag = true)
    {
        $this->_disableHooks = (bool)$flag;
    }
    protected function runHooks()
    {
        if (!$this->_disableHooks)
            $this->getDi()->userTable->load($this->user_id)->checkSubscriptions(true);
    }
    public function insert($reload = true)
    {
        parent::insert($reload);
        $this->runHooks();
        $this->getDi()->hook->call(Am_Event::ACCESS_AFTER_INSERT, array('access' =>$this));
        return $this;
    }
    public function delete()
    {
        parent::delete();
        $this->runHooks();
        $this->getDi()->hook->call(Am_Event::ACCESS_AFTER_DELETE, array('access' =>$this));
        return $this;
    }
    public function update()
    {
        $hm = $this->getDi()->hook;
        if ($hm->have(Am_Event::ACCESS_AFTER_UPDATE))
        {
            $old = $this->getTable()->load($this->pk());
        }
        parent::update();
        $this->runHooks();
        if ($hm->have(Am_Event::ACCESS_AFTER_UPDATE))
        {
            $this->getDi()->hook->call(Am_Event::ACCESS_AFTER_UPDATE, array('access' => $this, 'old' => $old));
        }
        return $this;
    }
    /**
     * @return Invoice|null there can be access records without invoice
     */
    public function getInvoice()
    {
        if (!empty($this->invoice_id))
            return $this->getDi()->invoiceTable->load($this->invoice_id);
    }
    /**
     * @return User
     */
    public function getUser()
    {
        return $this->getDi()->userTable->load($this->user_id);
    }
}

class AccessTable extends Am_Table {
    protected $_key = 'access_id';
    protected $_table = '?_access';
    protected $_recordClass = 'Access';
    
    /*
     * Return status of member subscriptions
     * according to access table:
     * @return array product_id => status (1 if active, 2 if expired)
     */
    function getStatusByUserId($user_id, $statusFilter=DBSIMPLE_SKIP)
    {
        return $this->_db->selectCol(
           "SELECT 
               product_id as ARRAY_KEY,
               MIN(IF(expire_date<?,2,1)) as status
            FROM ?_access
            WHERE user_id=?d AND begin_date <= ?
            GROUP BY product_id
            {HAVING status = ?}
            ", $this->getDi()->sqlDate, $user_id, $this->getDi()->sqlDate, $statusFilter);
    }
    
    /**
     * As new recurring payment added, we will set existing recurring
     * records to "expire" at yesterday
     * No hook calls required as new subscription will be added instead
     */
    function setDateForRecurring(InvoiceItem $item, $date)
    {
        $this->_db->query("UPDATE ?_access
            SET expire_date=?
            WHERE invoice_id=?d AND product_id=?d AND expire_date IN (?,?)",
            $date,
            $item->invoice_id, $item->item_id, 
                Am_Period::MAX_SQL_DATE, Am_Period::RECURRING_SQL_DATE
            );
    }
    
    function getLastExpire(array $options)
    {
        return $this->_db->selectCell("SELECT MAX(expire_date) FROM ?_access
            WHERE user_id=?d
                { AND (
                    ?d = -1 #fake condition for DBSIMPLE_SKIP
                    { OR (product_id=?d) } 
                    { OR (product_id IN (SELECT product_id FROM ?_product WHERE renewal_group=?) ) }
                ) }
            ",
            $options['user_id'],
            (empty($options['product_id'])&&empty($options['renewal_group']))?DBSIMPLE_SKIP:1,
            !empty($options['product_id']) ? $options['product_id'] : DBSIMPLE_SKIP,
            !empty($options['renewal_group']) ? $options['renewal_group'] : DBSIMPLE_SKIP
            );
    }
    
    function queryExpirations(array $dates = array())
    {
        $where = "";
        if ($dates)
        {
            foreach ($dates as &$d) $d = "'$d'";
            $where .= sprintf(" AND expire_date IN (%s)", join(',', $dates));
        }
        return $this->_db->queryResultOnly("
        SELECT u.*, a.product_id AS _product_id, a.expire_date as _expire_date,
            i.invoice_id AS _recurring_invoice_id
        FROM 
            (SELECT user_id, MAX(expire_date) as max_expire
                  FROM ?_access
                  WHERE invoice_id > 0 
                  GROUP BY user_id) AS aa
            LEFT JOIN ?_access a
                 ON a.user_id = aa.user_id AND a.expire_date = aa.max_expire
            LEFT JOIN ?_user u ON u.user_id = a.user_id
            LEFT JOIN ?_invoice i ON i.user_id = a.user_id AND i.status = ?d
            WHERE a.invoice_id > 0 $where
            HAVING i.invoice_id IS NULL
            ", Invoice::RECURRING_ACTIVE);
    }
}
